{"ast":null,"code":"'use strict';\n\nconst inspect = require('util').inspect;\n\nconst isPromise = require('./is-promise');\n\nconst {\n  applyMiddleware,\n  commandMiddlewareFactory\n} = require('./middleware');\n\nconst path = require('path');\n\nconst Parser = require('yargs-parser');\n\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/; // handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\n\nmodule.exports = function command(yargs, usage, validation, globalMiddleware) {\n  const self = {};\n  let handlers = {};\n  let aliasMap = {};\n  let defaultCommand;\n  globalMiddleware = globalMiddleware || [];\n\n  self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware) {\n    let aliases = [];\n    const middlewares = commandMiddlewareFactory(commandMiddleware);\n\n    handler = handler || (() => {});\n\n    if (Array.isArray(cmd)) {\n      aliases = cmd.slice(1);\n      cmd = cmd[0];\n    } else if (typeof cmd === 'object') {\n      let command = Array.isArray(cmd.command) || typeof cmd.command === 'string' ? cmd.command : moduleName(cmd);\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases);\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares);\n      return;\n    } // allow a module to be provided instead of separate builder and handler\n\n\n    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares);\n      return;\n    } // parse positionals out of cmd string\n\n\n    const parsedCommand = self.parseCommand(cmd); // remove positional args from aliases only\n\n    aliases = aliases.map(alias => self.parseCommand(alias).cmd); // check for default and filter out '*''\n\n    let isDefault = false;\n    const parsedAliases = [parsedCommand.cmd].concat(aliases).filter(c => {\n      if (DEFAULT_MARKER.test(c)) {\n        isDefault = true;\n        return false;\n      }\n\n      return true;\n    }); // standardize on $0 for default command.\n\n    if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0'); // shift cmd and aliases after filtering out '*'\n\n    if (isDefault) {\n      parsedCommand.cmd = parsedAliases[0];\n      aliases = parsedAliases.slice(1);\n      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n    } // populate aliasMap\n\n\n    aliases.forEach(alias => {\n      aliasMap[alias] = parsedCommand.cmd;\n    });\n\n    if (description !== false) {\n      usage.command(cmd, description, isDefault, aliases);\n    }\n\n    handlers[parsedCommand.cmd] = {\n      original: cmd,\n      description: description,\n      handler,\n      builder: builder || {},\n      middlewares: middlewares || [],\n      demanded: parsedCommand.demanded,\n      optional: parsedCommand.optional\n    };\n    if (isDefault) defaultCommand = handlers[parsedCommand.cmd];\n  };\n\n  self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {\n    opts = opts || {}; // disable recursion to support nested directories of subcommands\n\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false; // exclude 'json', 'coffee' from require-directory defaults\n\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']; // allow consumer to define their own visitor function\n\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : o => o; // call addHandler via visitor function\n\n    opts.visit = function visit(obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename); // allow consumer to skip modules with their own visitor\n\n      if (visited) {\n        // check for cyclic reference\n        // each command file path should only be seen once per execution\n        if (~context.files.indexOf(joined)) return visited; // keep track of visited files in context.files\n\n        context.files.push(joined);\n        self.addHandler(visited);\n      }\n\n      return visited;\n    };\n\n    require('require-directory')({\n      require: req,\n      filename: callerFile\n    }, dir, opts);\n  }; // lookup module object from require()d command and derive name\n  // if module was not require()d and no name given, throw error\n\n\n  function moduleName(obj) {\n    const mod = require('which-module')(obj);\n\n    if (!mod) throw new Error(`No command name given for module: ${inspect(obj)}`);\n    return commandFromFilename(mod.filename);\n  } // derive command name from filename\n\n\n  function commandFromFilename(filename) {\n    return path.basename(filename, path.extname(filename));\n  }\n\n  function extractDesc(obj) {\n    for (let keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {\n      test = obj[keys[i]];\n      if (typeof test === 'string' || typeof test === 'boolean') return test;\n    }\n\n    return false;\n  }\n\n  self.parseCommand = function parseCommand(cmd) {\n    const extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ');\n    const splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/);\n    const bregex = /\\.*[\\][<>]/g;\n    const parsedCommand = {\n      cmd: splitCommand.shift().replace(bregex, ''),\n      demanded: [],\n      optional: []\n    };\n    splitCommand.forEach((cmd, i) => {\n      let variadic = false;\n      cmd = cmd.replace(/\\s/g, '');\n      if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true;\n\n      if (/^\\[/.test(cmd)) {\n        parsedCommand.optional.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        });\n      } else {\n        parsedCommand.demanded.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        });\n      }\n    });\n    return parsedCommand;\n  };\n\n  self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));\n\n  self.getCommandHandlers = () => handlers;\n\n  self.hasDefaultCommand = () => !!defaultCommand;\n\n  self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {\n    let aliases = parsed.aliases;\n    const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n    const currentContext = yargs.getContext();\n    let numFiles = currentContext.files.length;\n    const parentCommands = currentContext.commands.slice(); // what does yargs look like after the buidler is run?\n\n    let innerArgv = parsed.argv;\n    let innerYargs = null;\n    let positionalMap = {};\n\n    if (command) {\n      currentContext.commands.push(command);\n      currentContext.fullCommands.push(commandHandler.original);\n    }\n\n    if (typeof commandHandler.builder === 'function') {\n      // a function can be provided, which builds\n      // up a yargs chain and possibly returns it.\n      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases)); // if the builder function did not yet parse argv with reset yargs\n      // and did not explicitly set a usage() string, then apply the\n      // original command string as usage() for consistent behavior with\n      // options object below.\n\n      if (yargs.parsed === false) {\n        if (shouldUpdateUsage(yargs)) {\n          yargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n        }\n\n        innerArgv = innerYargs ? innerYargs._parseArgs(null, null, true, commandIndex) : yargs._parseArgs(null, null, true, commandIndex);\n      } else {\n        innerArgv = yargs.parsed.argv;\n      }\n\n      if (innerYargs && yargs.parsed === false) aliases = innerYargs.parsed.aliases;else aliases = yargs.parsed.aliases;\n    } else if (typeof commandHandler.builder === 'object') {\n      // as a short hand, an object can instead be provided, specifying\n      // the options that a command takes.\n      innerYargs = yargs.reset(parsed.aliases);\n\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n      }\n\n      Object.keys(commandHandler.builder).forEach(key => {\n        innerYargs.option(key, commandHandler.builder[key]);\n      });\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n      aliases = innerYargs.parsed.aliases;\n    }\n\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs);\n    }\n\n    const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares || []);\n    applyMiddleware(innerArgv, yargs, middlewares, true); // we apply validation post-hoc, so that custom\n    // checks get passed populated positional arguments.\n\n    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error);\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput();\n\n      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);\n      const handlerResult = isPromise(innerArgv) ? innerArgv.then(argv => commandHandler.handler(argv)) : commandHandler.handler(innerArgv);\n\n      if (isPromise(handlerResult)) {\n        handlerResult.catch(error => yargs.getUsageInstance().fail(null, error));\n      }\n    }\n\n    if (command) {\n      currentContext.commands.pop();\n      currentContext.fullCommands.pop();\n    }\n\n    numFiles = currentContext.files.length - numFiles;\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles);\n    return innerArgv;\n  };\n\n  function shouldUpdateUsage(yargs) {\n    return !yargs.getUsageInstance().getUsageDisabled() && yargs.getUsageInstance().getUsage().length === 0;\n  }\n\n  function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {\n    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;\n    const pc = parentCommands.filter(c => {\n      return !DEFAULT_MARKER.test(c);\n    });\n    pc.push(c);\n    return `$0 ${pc.join(' ')}`;\n  }\n\n  self.runDefaultBuilderOn = function (yargs) {\n    if (shouldUpdateUsage(yargs)) {\n      // build the root-level command string from the default string.\n      const commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ');\n      yargs.getUsageInstance().usage(commandString, defaultCommand.description);\n    }\n\n    const builder = defaultCommand.builder;\n\n    if (typeof builder === 'function') {\n      builder(yargs);\n    } else {\n      Object.keys(builder).forEach(key => {\n        yargs.option(key, builder[key]);\n      });\n    }\n  }; // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n  // onto argv.\n\n\n  function populatePositionals(commandHandler, argv, context, yargs) {\n    argv._ = argv._.slice(context.commands.length); // nuke the current commands\n\n    const demanded = commandHandler.demanded.slice(0);\n    const optional = commandHandler.optional.slice(0);\n    const positionalMap = {};\n    validation.positionalCount(demanded.length, argv._.length);\n\n    while (demanded.length) {\n      const demand = demanded.shift();\n      populatePositional(demand, argv, positionalMap);\n    }\n\n    while (optional.length) {\n      const maybe = optional.shift();\n      populatePositional(maybe, argv, positionalMap);\n    }\n\n    argv._ = context.commands.concat(argv._);\n    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));\n    return positionalMap;\n  }\n\n  function populatePositional(positional, argv, positionalMap, parseOptions) {\n    const cmd = positional.cmd[0];\n\n    if (positional.variadic) {\n      positionalMap[cmd] = argv._.splice(0).map(String);\n    } else {\n      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())];\n    }\n  } // we run yargs-parser against the positional arguments\n  // applying the same parsing logic used for flags.\n\n\n  function postProcessPositionals(argv, positionalMap, parseOptions) {\n    // combine the parsing hints we've inferred from the command\n    // string with explicitly configured parsing hints.\n    const options = Object.assign({}, yargs.getOptions());\n    options.default = Object.assign(parseOptions.default, options.default);\n    options.alias = Object.assign(parseOptions.alias, options.alias);\n    options.array = options.array.concat(parseOptions.array);\n    delete options.config; //  don't load config when processing positionals.\n\n    const unparsed = [];\n    Object.keys(positionalMap).forEach(key => {\n      positionalMap[key].map(value => {\n        unparsed.push(`--${key}`);\n        unparsed.push(value);\n      });\n    }); // short-circuit parse.\n\n    if (!unparsed.length) return;\n    const parsed = Parser.detailed(unparsed, options);\n\n    if (parsed.error) {\n      yargs.getUsageInstance().fail(parsed.error.message, parsed.error);\n    } else {\n      // only copy over positional keys (don't overwrite\n      // flag arguments that were already parsed).\n      const positionalKeys = Object.keys(positionalMap);\n      Object.keys(positionalMap).forEach(key => {\n        [].push.apply(positionalKeys, parsed.aliases[key]);\n      });\n      Object.keys(parsed.argv).forEach(key => {\n        if (positionalKeys.indexOf(key) !== -1) {\n          // any new aliases need to be placed in positionalMap, which\n          // is used for validation.\n          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];\n          argv[key] = parsed.argv[key];\n        }\n      });\n    }\n  }\n\n  self.cmdToParseOptions = function (cmdString) {\n    const parseOptions = {\n      array: [],\n      default: {},\n      alias: {},\n      demand: {}\n    };\n    const parsed = self.parseCommand(cmdString);\n    parsed.demanded.forEach(d => {\n      const cmds = d.cmd.slice(0);\n      const cmd = cmds.shift();\n\n      if (d.variadic) {\n        parseOptions.array.push(cmd);\n        parseOptions.default[cmd] = [];\n      }\n\n      cmds.forEach(c => {\n        parseOptions.alias[cmd] = c;\n      });\n      parseOptions.demand[cmd] = true;\n    });\n    parsed.optional.forEach(o => {\n      const cmds = o.cmd.slice(0);\n      const cmd = cmds.shift();\n\n      if (o.variadic) {\n        parseOptions.array.push(cmd);\n        parseOptions.default[cmd] = [];\n      }\n\n      cmds.forEach(c => {\n        parseOptions.alias[cmd] = c;\n      });\n    });\n    return parseOptions;\n  };\n\n  self.reset = () => {\n    handlers = {};\n    aliasMap = {};\n    defaultCommand = undefined;\n    return self;\n  }; // used by yargs.parse() to freeze\n  // the state of commands such that\n  // we can apply .parse() multiple times\n  // with the same yargs instance.\n\n\n  let frozen;\n\n  self.freeze = () => {\n    frozen = {};\n    frozen.handlers = handlers;\n    frozen.aliasMap = aliasMap;\n    frozen.defaultCommand = defaultCommand;\n  };\n\n  self.unfreeze = () => {\n    handlers = frozen.handlers;\n    aliasMap = frozen.aliasMap;\n    defaultCommand = frozen.defaultCommand;\n    frozen = undefined;\n  };\n\n  return self;\n};","map":{"version":3,"sources":["/Users/kathryncrisafulli/Desktop/clueless_git/UnitedCoders/clueless_react/node_modules/yargs/lib/command.js"],"names":["inspect","require","isPromise","applyMiddleware","commandMiddlewareFactory","path","Parser","DEFAULT_MARKER","module","exports","command","yargs","usage","validation","globalMiddleware","self","handlers","aliasMap","defaultCommand","addHandler","cmd","description","builder","handler","commandMiddleware","aliases","middlewares","Array","isArray","slice","moduleName","concat","extractDesc","parsedCommand","parseCommand","map","alias","isDefault","parsedAliases","filter","c","test","length","push","replace","forEach","original","demanded","optional","addDirectory","dir","context","req","callerFile","opts","recurse","extensions","parentVisit","visit","o","obj","joined","filename","visited","files","indexOf","mod","Error","commandFromFilename","basename","extname","keys","i","l","extraSpacesStrippedCommand","splitCommand","split","bregex","shift","variadic","getCommands","Object","getCommandHandlers","hasDefaultCommand","runCommand","parsed","commandIndex","commandHandler","currentContext","getContext","numFiles","parentCommands","commands","innerArgv","argv","innerYargs","positionalMap","fullCommands","reset","shouldUpdateUsage","getUsageInstance","usageFromParentCommandsCommandHandler","_parseArgs","key","option","_hasOutput","populatePositionals","_runValidation","error","_setHasOutput","handlerResult","then","catch","fail","pop","splice","getUsageDisabled","getUsage","trim","pc","join","runDefaultBuilderOn","commandString","_","positionalCount","demand","populatePositional","maybe","postProcessPositionals","cmdToParseOptions","positional","parseOptions","String","options","assign","getOptions","default","array","config","unparsed","value","detailed","message","positionalKeys","apply","cmdString","d","cmds","undefined","frozen","freeze","unfreeze"],"mappings":"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","sourcesContent":["'use strict'\n\nconst inspect = require('util').inspect\nconst isPromise = require('./is-promise')\nconst { applyMiddleware, commandMiddlewareFactory } = require('./middleware')\nconst path = require('path')\nconst Parser = require('yargs-parser')\n\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/\n\n// handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\nmodule.exports = function command (yargs, usage, validation, globalMiddleware) {\n  const self = {}\n  let handlers = {}\n  let aliasMap = {}\n  let defaultCommand\n  globalMiddleware = globalMiddleware || []\n\n  self.addHandler = function addHandler (cmd, description, builder, handler, commandMiddleware) {\n    let aliases = []\n    const middlewares = commandMiddlewareFactory(commandMiddleware)\n    handler = handler || (() => {})\n\n    if (Array.isArray(cmd)) {\n      aliases = cmd.slice(1)\n      cmd = cmd[0]\n    } else if (typeof cmd === 'object') {\n      let command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd)\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases)\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares)\n      return\n    }\n\n    // allow a module to be provided instead of separate builder and handler\n    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares)\n      return\n    }\n\n    // parse positionals out of cmd string\n    const parsedCommand = self.parseCommand(cmd)\n\n    // remove positional args from aliases only\n    aliases = aliases.map(alias => self.parseCommand(alias).cmd)\n\n    // check for default and filter out '*''\n    let isDefault = false\n    const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {\n      if (DEFAULT_MARKER.test(c)) {\n        isDefault = true\n        return false\n      }\n      return true\n    })\n\n    // standardize on $0 for default command.\n    if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0')\n\n    // shift cmd and aliases after filtering out '*'\n    if (isDefault) {\n      parsedCommand.cmd = parsedAliases[0]\n      aliases = parsedAliases.slice(1)\n      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd)\n    }\n\n    // populate aliasMap\n    aliases.forEach((alias) => {\n      aliasMap[alias] = parsedCommand.cmd\n    })\n\n    if (description !== false) {\n      usage.command(cmd, description, isDefault, aliases)\n    }\n\n    handlers[parsedCommand.cmd] = {\n      original: cmd,\n      description: description,\n      handler,\n      builder: builder || {},\n      middlewares: middlewares || [],\n      demanded: parsedCommand.demanded,\n      optional: parsedCommand.optional\n    }\n\n    if (isDefault) defaultCommand = handlers[parsedCommand.cmd]\n  }\n\n  self.addDirectory = function addDirectory (dir, context, req, callerFile, opts) {\n    opts = opts || {}\n    // disable recursion to support nested directories of subcommands\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false\n    // exclude 'json', 'coffee' from require-directory defaults\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']\n    // allow consumer to define their own visitor function\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : o => o\n    // call addHandler via visitor function\n    opts.visit = function visit (obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename)\n      // allow consumer to skip modules with their own visitor\n      if (visited) {\n        // check for cyclic reference\n        // each command file path should only be seen once per execution\n        if (~context.files.indexOf(joined)) return visited\n        // keep track of visited files in context.files\n        context.files.push(joined)\n        self.addHandler(visited)\n      }\n      return visited\n    }\n    require('require-directory')({ require: req, filename: callerFile }, dir, opts)\n  }\n\n  // lookup module object from require()d command and derive name\n  // if module was not require()d and no name given, throw error\n  function moduleName (obj) {\n    const mod = require('which-module')(obj)\n    if (!mod) throw new Error(`No command name given for module: ${inspect(obj)}`)\n    return commandFromFilename(mod.filename)\n  }\n\n  // derive command name from filename\n  function commandFromFilename (filename) {\n    return path.basename(filename, path.extname(filename))\n  }\n\n  function extractDesc (obj) {\n    for (let keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {\n      test = obj[keys[i]]\n      if (typeof test === 'string' || typeof test === 'boolean') return test\n    }\n    return false\n  }\n\n  self.parseCommand = function parseCommand (cmd) {\n    const extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ')\n    const splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/)\n    const bregex = /\\.*[\\][<>]/g\n    const parsedCommand = {\n      cmd: (splitCommand.shift()).replace(bregex, ''),\n      demanded: [],\n      optional: []\n    }\n    splitCommand.forEach((cmd, i) => {\n      let variadic = false\n      cmd = cmd.replace(/\\s/g, '')\n      if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true\n      if (/^\\[/.test(cmd)) {\n        parsedCommand.optional.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        })\n      } else {\n        parsedCommand.demanded.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        })\n      }\n    })\n    return parsedCommand\n  }\n\n  self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap))\n\n  self.getCommandHandlers = () => handlers\n\n  self.hasDefaultCommand = () => !!defaultCommand\n\n  self.runCommand = function runCommand (command, yargs, parsed, commandIndex) {\n    let aliases = parsed.aliases\n    const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand\n    const currentContext = yargs.getContext()\n    let numFiles = currentContext.files.length\n    const parentCommands = currentContext.commands.slice()\n\n    // what does yargs look like after the buidler is run?\n    let innerArgv = parsed.argv\n    let innerYargs = null\n    let positionalMap = {}\n    if (command) {\n      currentContext.commands.push(command)\n      currentContext.fullCommands.push(commandHandler.original)\n    }\n    if (typeof commandHandler.builder === 'function') {\n      // a function can be provided, which builds\n      // up a yargs chain and possibly returns it.\n      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases))\n      // if the builder function did not yet parse argv with reset yargs\n      // and did not explicitly set a usage() string, then apply the\n      // original command string as usage() for consistent behavior with\n      // options object below.\n      if (yargs.parsed === false) {\n        if (shouldUpdateUsage(yargs)) {\n          yargs.getUsageInstance().usage(\n            usageFromParentCommandsCommandHandler(parentCommands, commandHandler),\n            commandHandler.description\n          )\n        }\n        innerArgv = innerYargs ? innerYargs._parseArgs(null, null, true, commandIndex) : yargs._parseArgs(null, null, true, commandIndex)\n      } else {\n        innerArgv = yargs.parsed.argv\n      }\n\n      if (innerYargs && yargs.parsed === false) aliases = innerYargs.parsed.aliases\n      else aliases = yargs.parsed.aliases\n    } else if (typeof commandHandler.builder === 'object') {\n      // as a short hand, an object can instead be provided, specifying\n      // the options that a command takes.\n      innerYargs = yargs.reset(parsed.aliases)\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(\n          usageFromParentCommandsCommandHandler(parentCommands, commandHandler),\n          commandHandler.description\n        )\n      }\n      Object.keys(commandHandler.builder).forEach((key) => {\n        innerYargs.option(key, commandHandler.builder[key])\n      })\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex)\n      aliases = innerYargs.parsed.aliases\n    }\n\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs)\n    }\n\n    const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares || [])\n    applyMiddleware(innerArgv, yargs, middlewares, true)\n\n    // we apply validation post-hoc, so that custom\n    // checks get passed populated positional arguments.\n    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error)\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput()\n\n      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false)\n\n      const handlerResult = isPromise(innerArgv)\n        ? innerArgv.then(argv => commandHandler.handler(argv))\n        : commandHandler.handler(innerArgv)\n\n      if (isPromise(handlerResult)) {\n        handlerResult.catch(error =>\n          yargs.getUsageInstance().fail(null, error)\n        )\n      }\n    }\n\n    if (command) {\n      currentContext.commands.pop()\n      currentContext.fullCommands.pop()\n    }\n    numFiles = currentContext.files.length - numFiles\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles)\n\n    return innerArgv\n  }\n\n  function shouldUpdateUsage (yargs) {\n    return !yargs.getUsageInstance().getUsageDisabled() &&\n      yargs.getUsageInstance().getUsage().length === 0\n  }\n\n  function usageFromParentCommandsCommandHandler (parentCommands, commandHandler) {\n    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original\n    const pc = parentCommands.filter((c) => { return !DEFAULT_MARKER.test(c) })\n    pc.push(c)\n    return `$0 ${pc.join(' ')}`\n  }\n\n  self.runDefaultBuilderOn = function (yargs) {\n    if (shouldUpdateUsage(yargs)) {\n      // build the root-level command string from the default string.\n      const commandString = DEFAULT_MARKER.test(defaultCommand.original)\n        ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ')\n      yargs.getUsageInstance().usage(\n        commandString,\n        defaultCommand.description\n      )\n    }\n    const builder = defaultCommand.builder\n    if (typeof builder === 'function') {\n      builder(yargs)\n    } else {\n      Object.keys(builder).forEach((key) => {\n        yargs.option(key, builder[key])\n      })\n    }\n  }\n\n  // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n  // onto argv.\n  function populatePositionals (commandHandler, argv, context, yargs) {\n    argv._ = argv._.slice(context.commands.length) // nuke the current commands\n    const demanded = commandHandler.demanded.slice(0)\n    const optional = commandHandler.optional.slice(0)\n    const positionalMap = {}\n\n    validation.positionalCount(demanded.length, argv._.length)\n\n    while (demanded.length) {\n      const demand = demanded.shift()\n      populatePositional(demand, argv, positionalMap)\n    }\n\n    while (optional.length) {\n      const maybe = optional.shift()\n      populatePositional(maybe, argv, positionalMap)\n    }\n\n    argv._ = context.commands.concat(argv._)\n\n    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original))\n\n    return positionalMap\n  }\n\n  function populatePositional (positional, argv, positionalMap, parseOptions) {\n    const cmd = positional.cmd[0]\n    if (positional.variadic) {\n      positionalMap[cmd] = argv._.splice(0).map(String)\n    } else {\n      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())]\n    }\n  }\n\n  // we run yargs-parser against the positional arguments\n  // applying the same parsing logic used for flags.\n  function postProcessPositionals (argv, positionalMap, parseOptions) {\n    // combine the parsing hints we've inferred from the command\n    // string with explicitly configured parsing hints.\n    const options = Object.assign({}, yargs.getOptions())\n    options.default = Object.assign(parseOptions.default, options.default)\n    options.alias = Object.assign(parseOptions.alias, options.alias)\n    options.array = options.array.concat(parseOptions.array)\n    delete options.config //  don't load config when processing positionals.\n\n    const unparsed = []\n    Object.keys(positionalMap).forEach((key) => {\n      positionalMap[key].map((value) => {\n        unparsed.push(`--${key}`)\n        unparsed.push(value)\n      })\n    })\n\n    // short-circuit parse.\n    if (!unparsed.length) return\n\n    const parsed = Parser.detailed(unparsed, options)\n\n    if (parsed.error) {\n      yargs.getUsageInstance().fail(parsed.error.message, parsed.error)\n    } else {\n      // only copy over positional keys (don't overwrite\n      // flag arguments that were already parsed).\n      const positionalKeys = Object.keys(positionalMap)\n      Object.keys(positionalMap).forEach((key) => {\n        [].push.apply(positionalKeys, parsed.aliases[key])\n      })\n\n      Object.keys(parsed.argv).forEach((key) => {\n        if (positionalKeys.indexOf(key) !== -1) {\n          // any new aliases need to be placed in positionalMap, which\n          // is used for validation.\n          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key]\n          argv[key] = parsed.argv[key]\n        }\n      })\n    }\n  }\n\n  self.cmdToParseOptions = function (cmdString) {\n    const parseOptions = {\n      array: [],\n      default: {},\n      alias: {},\n      demand: {}\n    }\n\n    const parsed = self.parseCommand(cmdString)\n    parsed.demanded.forEach((d) => {\n      const cmds = d.cmd.slice(0)\n      const cmd = cmds.shift()\n      if (d.variadic) {\n        parseOptions.array.push(cmd)\n        parseOptions.default[cmd] = []\n      }\n      cmds.forEach((c) => {\n        parseOptions.alias[cmd] = c\n      })\n      parseOptions.demand[cmd] = true\n    })\n\n    parsed.optional.forEach((o) => {\n      const cmds = o.cmd.slice(0)\n      const cmd = cmds.shift()\n      if (o.variadic) {\n        parseOptions.array.push(cmd)\n        parseOptions.default[cmd] = []\n      }\n      cmds.forEach((c) => {\n        parseOptions.alias[cmd] = c\n      })\n    })\n\n    return parseOptions\n  }\n\n  self.reset = () => {\n    handlers = {}\n    aliasMap = {}\n    defaultCommand = undefined\n    return self\n  }\n\n  // used by yargs.parse() to freeze\n  // the state of commands such that\n  // we can apply .parse() multiple times\n  // with the same yargs instance.\n  let frozen\n  self.freeze = () => {\n    frozen = {}\n    frozen.handlers = handlers\n    frozen.aliasMap = aliasMap\n    frozen.defaultCommand = defaultCommand\n  }\n  self.unfreeze = () => {\n    handlers = frozen.handlers\n    aliasMap = frozen.aliasMap\n    defaultCommand = frozen.defaultCommand\n    frozen = undefined\n  }\n\n  return self\n}\n"]},"metadata":{},"sourceType":"script"}