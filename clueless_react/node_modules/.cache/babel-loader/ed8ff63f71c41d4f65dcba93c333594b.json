{"ast":null,"code":"'use strict';\n\nconst argsert = require('./argsert');\n\nconst objFilter = require('./obj-filter');\n\nconst specialKeys = ['$0', '--', '_']; // validation-type-stuff, missing params,\n// bad implications, custom checks.\n\nmodule.exports = function validation(yargs, usage, y18n) {\n  const __ = y18n.__;\n  const __n = y18n.__n;\n  const self = {}; // validate appropriate # of non-option\n  // arguments were provided, i.e., '_'.\n\n  self.nonOptionCount = function nonOptionCount(argv) {\n    const demandedCommands = yargs.getDemandedCommands(); // don't count currently executing commands\n\n    const _s = argv._.length - yargs.getContext().commands.length;\n\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail( // replace $0 with observed, $1 with expected.\n          demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.min) : null);\n        } else {\n          usage.fail(__('Not enough non-option arguments: got %s, need at least %s', _s, demandedCommands._.min));\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail( // replace $0 with observed, $1 with expected.\n          demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.max) : null);\n        } else {\n          usage.fail(__('Too many non-option arguments: got %s, maximum of %s', _s, demandedCommands._.max));\n        }\n      }\n    }\n  }; // validate the appropriate # of <required>\n  // positional arguments were provided:\n\n\n  self.positionalCount = function positionalCount(required, observed) {\n    if (observed < required) {\n      usage.fail(__('Not enough non-option arguments: got %s, need at least %s', observed, required));\n    }\n  }; // make sure all the required arguments are present.\n\n\n  self.requiredArguments = function requiredArguments(argv) {\n    const demandedOptions = yargs.getDemandedOptions();\n    let missing = null;\n    Object.keys(demandedOptions).forEach(key => {\n      if (!argv.hasOwnProperty(key) || typeof argv[key] === 'undefined') {\n        missing = missing || {};\n        missing[key] = demandedOptions[key];\n      }\n    });\n\n    if (missing) {\n      const customMsgs = [];\n      Object.keys(missing).forEach(key => {\n        const msg = missing[key];\n\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg);\n        }\n      });\n      const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n    }\n  }; // check for unknown arguments (strict-mode).\n\n\n  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap) {\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && !positionalMap.hasOwnProperty(key) && !yargs._getParseContext().hasOwnProperty(key) && !aliases.hasOwnProperty(key)) {\n        unknown.push(key);\n      }\n    });\n\n    if (commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf(key) === -1) {\n          unknown.push(key);\n        }\n      });\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n    }\n  }; // validate arguments limited to enumerated choices\n\n\n  self.limitedChoices = function limitedChoices(argv) {\n    const options = yargs.getOptions();\n    const invalid = {};\n    if (!Object.keys(options.choices).length) return;\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && options.choices.hasOwnProperty(key)) {\n        [].concat(argv[key]).forEach(value => {\n          // TODO case-insensitive configurability\n          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value);\n          }\n        });\n      }\n    });\n    const invalidKeys = Object.keys(invalid);\n    if (!invalidKeys.length) return;\n\n    let msg = __('Invalid values:');\n\n    invalidKeys.forEach(key => {\n      msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n    });\n    usage.fail(msg);\n  }; // custom checks, added using the `check` option on yargs.\n\n\n  let checks = [];\n\n  self.check = function check(f, global) {\n    checks.push({\n      func: f,\n      global\n    });\n  };\n\n  self.customChecks = function customChecks(argv, aliases) {\n    for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n      const func = f.func;\n      let result = null;\n\n      try {\n        result = func(argv, aliases);\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err);\n        continue;\n      }\n\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()));\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result);\n      }\n    }\n  }; // check implications, argument foo implies => argument bar.\n\n\n  let implied = {};\n\n  self.implies = function implies(key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.implies(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!implied[key]) {\n        implied[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.implies(key, i));\n      } else {\n        implied[key].push(value);\n      }\n    }\n  };\n\n  self.getImplied = function getImplied() {\n    return implied;\n  };\n\n  self.implications = function implications(argv) {\n    const implyFail = [];\n    Object.keys(implied).forEach(key => {\n      const origKey = key;\n      (implied[key] || []).forEach(value => {\n        let num;\n        let key = origKey;\n        const origValue = value; // convert string '1' to number 1\n\n        num = Number(key);\n        key = isNaN(num) ? key : num;\n\n        if (typeof key === 'number') {\n          // check length of argv._\n          key = argv._.length >= key;\n        } else if (key.match(/^--no-.+/)) {\n          // check if key doesn't exist\n          key = key.match(/^--no-(.+)/)[1];\n          key = !argv[key];\n        } else {\n          // check if key exists\n          key = argv[key];\n        }\n\n        num = Number(value);\n        value = isNaN(num) ? value : num;\n\n        if (typeof value === 'number') {\n          value = argv._.length >= value;\n        } else if (value.match(/^--no-.+/)) {\n          value = value.match(/^--no-(.+)/)[1];\n          value = !argv[value];\n        } else {\n          value = argv[value];\n        }\n\n        if (key && !value) {\n          implyFail.push(` ${origKey} -> ${origValue}`);\n        }\n      });\n    });\n\n    if (implyFail.length) {\n      let msg = `${__('Implications failed:')}\\n`;\n      implyFail.forEach(value => {\n        msg += value;\n      });\n      usage.fail(msg);\n    }\n  };\n\n  let conflicting = {};\n\n  self.conflicts = function conflicts(key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.conflicts(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!conflicting[key]) {\n        conflicting[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.conflicts(key, i));\n      } else {\n        conflicting[key].push(value);\n      }\n    }\n  };\n\n  self.getConflicting = () => conflicting;\n\n  self.conflicting = function conflictingFn(argv) {\n    Object.keys(argv).forEach(key => {\n      if (conflicting[key]) {\n        conflicting[key].forEach(value => {\n          // we default keys to 'undefined' that have been configured, we should not\n          // apply conflicting check unless they are a value other than 'undefined'.\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n          }\n        });\n      }\n    });\n  };\n\n  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n    const distance = require('./levenshtein');\n\n    const threshold = 3; // if it takes more than three edits, let's move on.\n\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n    let recommended = null;\n    let bestDistance = Infinity;\n\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = distance(cmd, candidate);\n\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d;\n        recommended = candidate;\n      }\n    }\n\n    if (recommended) usage.fail(__('Did you mean %s?', recommended));\n  };\n\n  self.reset = function reset(localLookup) {\n    implied = objFilter(implied, (k, v) => !localLookup[k]);\n    conflicting = objFilter(conflicting, (k, v) => !localLookup[k]);\n    checks = checks.filter(c => c.global);\n    return self;\n  };\n\n  let frozen;\n\n  self.freeze = function freeze() {\n    frozen = {};\n    frozen.implied = implied;\n    frozen.checks = checks;\n    frozen.conflicting = conflicting;\n  };\n\n  self.unfreeze = function unfreeze() {\n    implied = frozen.implied;\n    checks = frozen.checks;\n    conflicting = frozen.conflicting;\n    frozen = undefined;\n  };\n\n  return self;\n};","map":{"version":3,"sources":["/Users/kathryncrisafulli/Desktop/clueless_git/UnitedCoders/clueless_react/node_modules/yargs/lib/validation.js"],"names":["argsert","require","objFilter","specialKeys","module","exports","validation","yargs","usage","y18n","__","__n","self","nonOptionCount","argv","demandedCommands","getDemandedCommands","_s","_","length","getContext","commands","min","max","minMsg","undefined","fail","replace","maxMsg","positionalCount","required","observed","requiredArguments","demandedOptions","getDemandedOptions","missing","Object","keys","forEach","key","hasOwnProperty","customMsgs","msg","indexOf","push","customMsg","join","unknownArguments","aliases","positionalMap","commandKeys","getCommandInstance","getCommands","unknown","currentContext","_getParseContext","slice","limitedChoices","options","getOptions","invalid","choices","concat","value","invalidKeys","stringifiedValues","checks","check","f","global","func","customChecks","i","result","err","message","toString","Error","implied","implies","arguments","k","Array","isArray","getImplied","implications","implyFail","origKey","num","origValue","Number","isNaN","match","conflicting","conflicts","getConflicting","conflictingFn","recommendCommands","cmd","potentialCommands","distance","threshold","sort","a","b","recommended","bestDistance","Infinity","candidate","d","reset","localLookup","v","filter","c","frozen","freeze","unfreeze"],"mappings":"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","sourcesContent":["'use strict'\nconst argsert = require('./argsert')\nconst objFilter = require('./obj-filter')\nconst specialKeys = ['$0', '--', '_']\n\n// validation-type-stuff, missing params,\n// bad implications, custom checks.\nmodule.exports = function validation (yargs, usage, y18n) {\n  const __ = y18n.__\n  const __n = y18n.__n\n  const self = {}\n\n  // validate appropriate # of non-option\n  // arguments were provided, i.e., '_'.\n  self.nonOptionCount = function nonOptionCount (argv) {\n    const demandedCommands = yargs.getDemandedCommands()\n    // don't count currently executing commands\n    const _s = argv._.length - yargs.getContext().commands.length\n\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail(\n            // replace $0 with observed, $1 with expected.\n            demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.min) : null\n          )\n        } else {\n          usage.fail(\n            __('Not enough non-option arguments: got %s, need at least %s', _s, demandedCommands._.min)\n          )\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail(\n            // replace $0 with observed, $1 with expected.\n            demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.max) : null\n          )\n        } else {\n          usage.fail(\n            __('Too many non-option arguments: got %s, maximum of %s', _s, demandedCommands._.max)\n          )\n        }\n      }\n    }\n  }\n\n  // validate the appropriate # of <required>\n  // positional arguments were provided:\n  self.positionalCount = function positionalCount (required, observed) {\n    if (observed < required) {\n      usage.fail(\n        __('Not enough non-option arguments: got %s, need at least %s', observed, required)\n      )\n    }\n  }\n\n  // make sure all the required arguments are present.\n  self.requiredArguments = function requiredArguments (argv) {\n    const demandedOptions = yargs.getDemandedOptions()\n    let missing = null\n\n    Object.keys(demandedOptions).forEach((key) => {\n      if (!argv.hasOwnProperty(key) || typeof argv[key] === 'undefined') {\n        missing = missing || {}\n        missing[key] = demandedOptions[key]\n      }\n    })\n\n    if (missing) {\n      const customMsgs = []\n      Object.keys(missing).forEach((key) => {\n        const msg = missing[key]\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg)\n        }\n      })\n\n      const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : ''\n\n      usage.fail(__n(\n        'Missing required argument: %s',\n        'Missing required arguments: %s',\n        Object.keys(missing).length,\n        Object.keys(missing).join(', ') + customMsg\n      ))\n    }\n  }\n\n  // check for unknown arguments (strict-mode).\n  self.unknownArguments = function unknownArguments (argv, aliases, positionalMap) {\n    const commandKeys = yargs.getCommandInstance().getCommands()\n    const unknown = []\n    const currentContext = yargs.getContext()\n\n    Object.keys(argv).forEach((key) => {\n      if (specialKeys.indexOf(key) === -1 &&\n        !positionalMap.hasOwnProperty(key) &&\n        !yargs._getParseContext().hasOwnProperty(key) &&\n        !aliases.hasOwnProperty(key)\n      ) {\n        unknown.push(key)\n      }\n    })\n\n    if (commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach((key) => {\n        if (commandKeys.indexOf(key) === -1) {\n          unknown.push(key)\n        }\n      })\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n(\n        'Unknown argument: %s',\n        'Unknown arguments: %s',\n        unknown.length,\n        unknown.join(', ')\n      ))\n    }\n  }\n\n  // validate arguments limited to enumerated choices\n  self.limitedChoices = function limitedChoices (argv) {\n    const options = yargs.getOptions()\n    const invalid = {}\n\n    if (!Object.keys(options.choices).length) return\n\n    Object.keys(argv).forEach((key) => {\n      if (specialKeys.indexOf(key) === -1 &&\n        options.choices.hasOwnProperty(key)) {\n        [].concat(argv[key]).forEach((value) => {\n          // TODO case-insensitive configurability\n          if (options.choices[key].indexOf(value) === -1 &&\n              value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value)\n          }\n        })\n      }\n    })\n\n    const invalidKeys = Object.keys(invalid)\n\n    if (!invalidKeys.length) return\n\n    let msg = __('Invalid values:')\n    invalidKeys.forEach((key) => {\n      msg += `\\n  ${__(\n        'Argument: %s, Given: %s, Choices: %s',\n        key,\n        usage.stringifiedValues(invalid[key]),\n        usage.stringifiedValues(options.choices[key])\n      )}`\n    })\n    usage.fail(msg)\n  }\n\n  // custom checks, added using the `check` option on yargs.\n  let checks = []\n  self.check = function check (f, global) {\n    checks.push({\n      func: f,\n      global\n    })\n  }\n\n  self.customChecks = function customChecks (argv, aliases) {\n    for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n      const func = f.func\n      let result = null\n      try {\n        result = func(argv, aliases)\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err)\n        continue\n      }\n\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()))\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result)\n      }\n    }\n  }\n\n  // check implications, argument foo implies => argument bar.\n  let implied = {}\n  self.implies = function implies (key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length)\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach((k) => {\n        self.implies(k, key[k])\n      })\n    } else {\n      yargs.global(key)\n      if (!implied[key]) {\n        implied[key] = []\n      }\n      if (Array.isArray(value)) {\n        value.forEach((i) => self.implies(key, i))\n      } else {\n        implied[key].push(value)\n      }\n    }\n  }\n  self.getImplied = function getImplied () {\n    return implied\n  }\n\n  self.implications = function implications (argv) {\n    const implyFail = []\n\n    Object.keys(implied).forEach((key) => {\n      const origKey = key\n      ;(implied[key] || []).forEach((value) => {\n        let num\n        let key = origKey\n        const origValue = value\n\n        // convert string '1' to number 1\n        num = Number(key)\n        key = isNaN(num) ? key : num\n\n        if (typeof key === 'number') {\n          // check length of argv._\n          key = argv._.length >= key\n        } else if (key.match(/^--no-.+/)) {\n          // check if key doesn't exist\n          key = key.match(/^--no-(.+)/)[1]\n          key = !argv[key]\n        } else {\n          // check if key exists\n          key = argv[key]\n        }\n\n        num = Number(value)\n        value = isNaN(num) ? value : num\n\n        if (typeof value === 'number') {\n          value = argv._.length >= value\n        } else if (value.match(/^--no-.+/)) {\n          value = value.match(/^--no-(.+)/)[1]\n          value = !argv[value]\n        } else {\n          value = argv[value]\n        }\n        if (key && !value) {\n          implyFail.push(` ${origKey} -> ${origValue}`)\n        }\n      })\n    })\n\n    if (implyFail.length) {\n      let msg = `${__('Implications failed:')}\\n`\n\n      implyFail.forEach((value) => {\n        msg += (value)\n      })\n\n      usage.fail(msg)\n    }\n  }\n\n  let conflicting = {}\n  self.conflicts = function conflicts (key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length)\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach((k) => {\n        self.conflicts(k, key[k])\n      })\n    } else {\n      yargs.global(key)\n      if (!conflicting[key]) {\n        conflicting[key] = []\n      }\n      if (Array.isArray(value)) {\n        value.forEach((i) => self.conflicts(key, i))\n      } else {\n        conflicting[key].push(value)\n      }\n    }\n  }\n  self.getConflicting = () => conflicting\n\n  self.conflicting = function conflictingFn (argv) {\n    Object.keys(argv).forEach((key) => {\n      if (conflicting[key]) {\n        conflicting[key].forEach((value) => {\n          // we default keys to 'undefined' that have been configured, we should not\n          // apply conflicting check unless they are a value other than 'undefined'.\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value))\n          }\n        })\n      }\n    })\n  }\n\n  self.recommendCommands = function recommendCommands (cmd, potentialCommands) {\n    const distance = require('./levenshtein')\n    const threshold = 3 // if it takes more than three edits, let's move on.\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length)\n\n    let recommended = null\n    let bestDistance = Infinity\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = distance(cmd, candidate)\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d\n        recommended = candidate\n      }\n    }\n    if (recommended) usage.fail(__('Did you mean %s?', recommended))\n  }\n\n  self.reset = function reset (localLookup) {\n    implied = objFilter(implied, (k, v) => !localLookup[k])\n    conflicting = objFilter(conflicting, (k, v) => !localLookup[k])\n    checks = checks.filter(c => c.global)\n    return self\n  }\n\n  let frozen\n  self.freeze = function freeze () {\n    frozen = {}\n    frozen.implied = implied\n    frozen.checks = checks\n    frozen.conflicting = conflicting\n  }\n  self.unfreeze = function unfreeze () {\n    implied = frozen.implied\n    checks = frozen.checks\n    conflicting = frozen.conflicting\n    frozen = undefined\n  }\n\n  return self\n}\n"]},"metadata":{},"sourceType":"script"}