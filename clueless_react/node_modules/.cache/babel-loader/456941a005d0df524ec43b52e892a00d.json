{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst YError = require('./yerror');\n\nlet previouslyVisitedConfigs = [];\n\nfunction checkForCircularExtends(cfgPath) {\n  if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {\n    throw new YError(`Circular extended configurations: '${cfgPath}'.`);\n  }\n}\n\nfunction getPathToDefaultConfig(cwd, pathToExtend) {\n  return path.resolve(cwd, pathToExtend);\n}\n\nfunction applyExtends(config, cwd) {\n  let defaultConfig = {};\n\n  if (config.hasOwnProperty('extends')) {\n    if (typeof config.extends !== 'string') return defaultConfig;\n    const isPath = /\\.json|\\..*rc$/.test(config.extends);\n    let pathToDefault = null;\n\n    if (!isPath) {\n      try {\n        pathToDefault = require.resolve(config.extends);\n      } catch (err) {// most likely this simply isn't a module.\n      }\n    } else {\n      pathToDefault = getPathToDefaultConfig(cwd, config.extends);\n    } // maybe the module uses key for some other reason,\n    // err on side of caution.\n\n\n    if (!pathToDefault && !isPath) return config;\n    checkForCircularExtends(pathToDefault);\n    previouslyVisitedConfigs.push(pathToDefault);\n    defaultConfig = isPath ? JSON.parse(fs.readFileSync(pathToDefault, 'utf8')) : require(config.extends);\n    delete config.extends;\n    defaultConfig = applyExtends(defaultConfig, path.dirname(pathToDefault));\n  }\n\n  previouslyVisitedConfigs = [];\n  return Object.assign({}, defaultConfig, config);\n}\n\nmodule.exports = applyExtends;","map":{"version":3,"sources":["/Users/sidneyjackson/Desktop/GitHub Projects/UnitedCoders/clueless_react/node_modules/yargs/lib/apply-extends.js"],"names":["fs","require","path","YError","previouslyVisitedConfigs","checkForCircularExtends","cfgPath","indexOf","getPathToDefaultConfig","cwd","pathToExtend","resolve","applyExtends","config","defaultConfig","hasOwnProperty","extends","isPath","test","pathToDefault","err","push","JSON","parse","readFileSync","dirname","Object","assign","module","exports"],"mappings":"AACA;;AACA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,UAAD,CAAtB;;AAEA,IAAIG,wBAAwB,GAAG,EAA/B;;AAEA,SAASC,uBAAT,CAAkCC,OAAlC,EAA2C;AACzC,MAAIF,wBAAwB,CAACG,OAAzB,CAAiCD,OAAjC,IAA4C,CAAC,CAAjD,EAAoD;AAClD,UAAM,IAAIH,MAAJ,CAAY,sCAAqCG,OAAQ,IAAzD,CAAN;AACD;AACF;;AAED,SAASE,sBAAT,CAAiCC,GAAjC,EAAsCC,YAAtC,EAAoD;AAClD,SAAOR,IAAI,CAACS,OAAL,CAAaF,GAAb,EAAkBC,YAAlB,CAAP;AACD;;AAED,SAASE,YAAT,CAAuBC,MAAvB,EAA+BJ,GAA/B,EAAoC;AAClC,MAAIK,aAAa,GAAG,EAApB;;AAEA,MAAID,MAAM,CAACE,cAAP,CAAsB,SAAtB,CAAJ,EAAsC;AACpC,QAAI,OAAOF,MAAM,CAACG,OAAd,KAA0B,QAA9B,EAAwC,OAAOF,aAAP;AACxC,UAAMG,MAAM,GAAG,iBAAiBC,IAAjB,CAAsBL,MAAM,CAACG,OAA7B,CAAf;AACA,QAAIG,aAAa,GAAG,IAApB;;AACA,QAAI,CAACF,MAAL,EAAa;AACX,UAAI;AACFE,QAAAA,aAAa,GAAGlB,OAAO,CAACU,OAAR,CAAgBE,MAAM,CAACG,OAAvB,CAAhB;AACD,OAFD,CAEE,OAAOI,GAAP,EAAY,CACZ;AACD;AACF,KAND,MAMO;AACLD,MAAAA,aAAa,GAAGX,sBAAsB,CAACC,GAAD,EAAMI,MAAM,CAACG,OAAb,CAAtC;AACD,KAZmC,CAapC;AACA;;;AACA,QAAI,CAACG,aAAD,IAAkB,CAACF,MAAvB,EAA+B,OAAOJ,MAAP;AAE/BR,IAAAA,uBAAuB,CAACc,aAAD,CAAvB;AAEAf,IAAAA,wBAAwB,CAACiB,IAAzB,CAA8BF,aAA9B;AAEAL,IAAAA,aAAa,GAAGG,MAAM,GAAGK,IAAI,CAACC,KAAL,CAAWvB,EAAE,CAACwB,YAAH,CAAgBL,aAAhB,EAA+B,MAA/B,CAAX,CAAH,GAAwDlB,OAAO,CAACY,MAAM,CAACG,OAAR,CAArF;AACA,WAAOH,MAAM,CAACG,OAAd;AACAF,IAAAA,aAAa,GAAGF,YAAY,CAACE,aAAD,EAAgBZ,IAAI,CAACuB,OAAL,CAAaN,aAAb,CAAhB,CAA5B;AACD;;AAEDf,EAAAA,wBAAwB,GAAG,EAA3B;AAEA,SAAOsB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBb,aAAlB,EAAiCD,MAAjC,CAAP;AACD;;AAEDe,MAAM,CAACC,OAAP,GAAiBjB,YAAjB","sourcesContent":["\n'use strict'\nconst fs = require('fs')\nconst path = require('path')\nconst YError = require('./yerror')\n\nlet previouslyVisitedConfigs = []\n\nfunction checkForCircularExtends (cfgPath) {\n  if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {\n    throw new YError(`Circular extended configurations: '${cfgPath}'.`)\n  }\n}\n\nfunction getPathToDefaultConfig (cwd, pathToExtend) {\n  return path.resolve(cwd, pathToExtend)\n}\n\nfunction applyExtends (config, cwd) {\n  let defaultConfig = {}\n\n  if (config.hasOwnProperty('extends')) {\n    if (typeof config.extends !== 'string') return defaultConfig\n    const isPath = /\\.json|\\..*rc$/.test(config.extends)\n    let pathToDefault = null\n    if (!isPath) {\n      try {\n        pathToDefault = require.resolve(config.extends)\n      } catch (err) {\n        // most likely this simply isn't a module.\n      }\n    } else {\n      pathToDefault = getPathToDefaultConfig(cwd, config.extends)\n    }\n    // maybe the module uses key for some other reason,\n    // err on side of caution.\n    if (!pathToDefault && !isPath) return config\n\n    checkForCircularExtends(pathToDefault)\n\n    previouslyVisitedConfigs.push(pathToDefault)\n\n    defaultConfig = isPath ? JSON.parse(fs.readFileSync(pathToDefault, 'utf8')) : require(config.extends)\n    delete config.extends\n    defaultConfig = applyExtends(defaultConfig, path.dirname(pathToDefault))\n  }\n\n  previouslyVisitedConfigs = []\n\n  return Object.assign({}, defaultConfig, config)\n}\n\nmodule.exports = applyExtends\n"]},"metadata":{},"sourceType":"script"}